#块配置项由一个块配置项名和一对大括号组成 events http server location upstream等都是块配置项
#块配置项一定会用大括号把所属的一系列所属的配置项包含进来,表示大括号内的配置项同时生效
#块配置项可以嵌套,内层块直接继承外层块

#配置项单位 空间: K或者k千字节 M或m兆字节  时间:ms(毫秒),s(秒),m(分钟),h(小时),d(天),w(周),M(月),y(年)

#以守护进程方式运行Nginx  默认on
daemon on;

#以mater/worker(一个master进程管理多个worker进程)方式工作,如果关闭就不会fork出worker子进程,而是master进程自身来处理请求  默认on
master_process on;

#error日志设置 语法: error_log /path/file level;
#/path/file是一个具体文件, /path/file也可以设置为/dev/null,不再输出任何日志(关闭error日志的唯一手段)
#level是日志等级 debug info notice warn error crit alert emerg 从左到右等级依次增大 如果想把日志等级设置为debug,必须在configure时加入--with-debug配置项
error_log  /var/log/nginx/error.log error;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;


#限制coredump核心转储文件的大小,防止core文件过大占满了磁盘 语法: worker_rlimit_core size;
worker_rlimit_core 1024M;

#指定coredump文件生成目录,worker进程的工作目录,该配置的唯一用途是设置coredump文件防止的目录,协助定位问题,需要确保worke进程有权限向working_directory指定目录写入文件 语法: working_directory path;
working_directory /data/nginx;

#定义环境变量 语法: env VAR|VAR=VALUE; 该配置让用户直接操作操作系统上的环境变量
#嵌入其他配置文件 语法: inclue /path/file; 将其它配置文件嵌入到当前的nginx.conf文件中,参数可以是绝对路径也可以是相对路径(相对nginx配置目录)
#include nginx.d/http/server.casezheng.com.conf
#include nginx.d/*.conf

#pid文件路径 保存master进程ID的pid文件存储路径.默认和configure设置的--pid-path所指定位置相同,需要确认nginx有权在相应目录中建立pid文件
pid        /run/nginx.pid;

#ningx worker进程运行的用户及用户组
user  nginx;

#设置一个nginx worker进程可以打开的最大文件描述符个数
worker_rlimit_nofile 65535;

#限制信号队列 设置每个用户发往nginx的信号队列的大小,当某个用户的信号队列满了,该用户发送的信号量将被丢弃
#worker_rlimit_sigpending limit;

#nginx worker进程个数 在master/worker运行方式下,定义worker进程的个数
worker_processes  auto;

#绑定nginx worker进程到指定的CPU内核 语法: worker_cpu_affinity cpumask [cpumask...]; 该配置仅针对Linux操作系统有效

#SSL硬件加速 如果服务器上有SSL硬件加速设备,可以进行配置加快SSL协议的处理速度.用户可以使用OpenSSL提供的命令来查看是否有SSL硬件加速设备: openssl engine -t
#ssl_engine device;

#nginx worker进程的优先级设置, 优先级有静态优先级和进程执行情况共同决定.这里设置的是静态优先级. 语法: worker_priority nice;   nice -20 ~ +19, -20最高优先级 +19最低优先级 希望nginx占用更多系统资源可以将其设置小点,但不建议比内核进程的nice(-5)小.
#worker_priority 0;

include /usr/share/nginx/modules/*.conf;

events {
    #对指定的客户端输出debug级别的日志 语法: debug_connection [IP|CIDR];  该配置属于事件类配置,必须放在events配置块中才有效,值可以是IP地址或CIDR地址 可以用于高并发请求下定位问题
    debug_connection 127.0.0.1;
    debug_connection 127.0.0.0/24;
    
    #accept锁 accept_mutex是Nginx的负载均衡锁,让多个worker进程轮流的,序列化地与新的客户端建立TCP连接,当一个worker进程建立的连接达到worker_connections配置的最大连接数的7/8时,大大减少该worker进程试图建立新TCP连接的机会,以此实现所有worker进程上处理的客户端请求数尽量接近. accept锁默认打开,关闭后建立TCP连接的耗时会更短,但worker进程间的负载会不均衡,因此不建议关闭它
    accept_mutex on;

    #使用accept锁后真正建立连接的延迟时间 语法: accept_mutext_delay Nms;    在使用accept锁后,同一时间只有一个worker进程可以获取到accept锁,accept锁不是阻塞锁,如果获取不到会立即返回.如果有一个worker进程试图获取accept锁而没有获取到,至少要等accept_mutex_delay定义的时间间隔后才能再次试图获取锁.

    #批量建立新连接 当事件模型通知有新连接时,尽可能对本次调度中客户端发起的所有TCP请求都建立连接. 语法: multi_accept [on|off];
    multi_accept off;

    #选择事件模型 语法: use [kququ | rtsig | epoll | /dev/poll | select | poll | eventport]; nginx默认会选择最合适的事件模型
    use epoll;

    #每个worker可以处理的最大连接数
    worker_connections  1024;
}


http {

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #gzip  on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    include             /etc/nginx/default.d/*.conf;
    include             /etc/nginx/conf.d/*.conf;
    default_type        application/octet-stream;

    #server_names_hash_bucket_size设置nginx存储server_name的散列表每个散列桶占用的内存大小 适用于配置块:http,server,location 取值32,64,128
    server_names_hash_bucket_size 128;
    #server_names_hash_max_size影响散列表的冲突率,值越大消耗内存越多,散列key的冲突率约低,检索速度越快 适用于配置块:http,server,location
    server_names_hash_max_size 512;


    #server块 虚拟主机定义
    server {
        #监听端口 默认监听80端口 listen决定nginx服务如何监听端口.在listen后面可以只加IP地址,端口或主机名
        #listen 127.0.0.1:8080;
        #listen 127.0.0.1;  #不写端口时,默认监听80端口
        #listen *:80;
        #listen localhost:80;
        #listen后面也可以加其他参数
        #1. default/default_server: 将这个server块作为整个Web服务的默认server块.未设置则将nginx解析配置时找到的第一个server块作为默认块,当一个请求无法匹配配置文件中所有主机域名时,选择默认的虚拟主机.
        #2. backlog=num: 表示TCP中backlog队列的大小,默认为-1,表示不予设置.在TCP三次握手的工程中,进程还没有开始处理监听句柄,这时backlog队列会放置这些新连接.如果backlog队列已满,新的客户端试图建立新连接将会失败.
        #3. rcvbuf=size: 设置监听句柄的SO_RCVBUF参数 
        #4. sndbuf=size: 设置监听句柄的SO_SNDBUF参数
        #5. accept_filter: 设置accept过滤器,只对FreeBSD操作系统有效
        #6. deferred: 设置该参数,若用户发起建立连接请求,并且完成TCP的三次握手,内核也不会调度worker进程来处理这个连接,当用户真的发送请求数据时,内核才会调度worker进程处理这个连接,这个参数适合大并发的情况下,减轻worker进程的负担
        #7. bind: 绑定当前端口/地址对, 只有同时对一个端口监听多个地址才会生效
        #8. ssl: 在当前监听的端口上建立的连接必须基于SSL协议
        listen       80 default_server;
        listen       [::]:80 default_server;

        #主机名称 server_name可以跟多个主机名称
        #server_name  localhost test.casezheng.date;
        #server_name  localhost 127.0.0.1;
        #当nginx处理一个HTTP请求时,nginx取出header头中的host,与每个server中的server_name匹配.匹配规则如下:
        #1. 完全匹配server_name
        #2. 通配符在前面的server_name
        #3. 通配符在后面的server_name
        #4. 正则表达式才匹配的server_name
        #5. 前面都未匹配到,找listen配置项后加了default或default_server的server块
        #6. 前面都未匹配到,找匹配listen端口的第一个server块
        #server_name后面跟空字符串表示匹配没有host这个HTTP头部的请求
        server_name  localhost test.casezheng.date;

        #server_name_in_redirect 重定向主机名称 配合server_name使用,当打开时表示重定向请求时会使用server_name里配置的第一个主机名代替原先请求中的Host头部,关闭时表示在重定向请求时使用请求本身的Host头部. 适用于配置块:http,server,location  默认on
        server_name_in_redirect on;

        #charset koi8-r;

        #location 语法: location [=|~|~*|^~|@]/uri/ { ... } 适用于配置块:server  location尝试根据用户请求中的URI来匹配/uri表达式,如果可以匹配,就选择location块中的配置处理用户请求, 匹配规则如下:
        #1. =表示把URI作为字符串,以便与参数中的uri做完全匹配
        #2. ~表示匹配URI时是大小写敏感的
        #3. ~*表示匹配URI时忽略字母大小写问题
        #4. ^~表示匹配URI时只需要其前半部分与uri参数匹配即可
        #5. @表示仅用于nginx服务内部请求之间的重定向
        #在uri参数中可以使用正则表达式进行匹配
        #location存在顺序,当一个请求有可能匹配多个location时,该请求将被第一个location处
        
        root /data/nginx/;

        location = /test_root {
            #以root方式设置资源路径 适用于配置块: http,server,location,if  root根据完整的URI请求来映射
            #root /data/nginx/;
        }

        location = /test_alias {
            #以alias方式设置资源路径 适用于配置块: location alias在URI向实际文件路径的映射过程中,会丢弃掉location后面配置的那部分uri
            alias /data/nginx/test_alias/;
        }

        location / {
            #访问首页   语法: index file ...; 用ngx_http_index_module模块提供的index配置实现返回网站首页,nginx按照配置的顺序访问index后配置的文件
            root   /data/nginx;
            index  index.html index.htm;
        }

        #error_page code [code...][=|=answer-code]uri|@named_location  适用于配置块:http,server,location,if
        #当某个请求返回错误码时,如果匹配上了erro_page中设置的code,则重定向到新的URI中.
        #error_page  404              /404.html;
        #error_page  404 =200         /404.html;    #重定向后返回的错误码还是原来的,可以通过=更改返回的错误码
        #error_page  404 =            /404.html;    #也可以不指定确切的返回码,由重定向后实际处理的真实结果决定
        #如果不行修改URI,只是将错误请求重定向到另一个location处理,可以如下配置,将错误请求代理到http://test.casezheng.date/test_root上游服务器处理
        location /test_error_fallback {
            error_page 404 @fallback;
        }
        location @fallback {
            proxy_pass http://test.casezheng.date;
        }
        #递归使用error_page  recursive_error_pages [on|off]
        recursive_error_pages off;  #默认不允许递归定义error_page

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   /data/nginx;
        }

        location ^~ /test_try_files {
            #try_files后跟若干路径,最后必须有uri参数. nginx尝试按顺序访问每个路径,如果可以有效访问则返回,否则继续读取下一个.如果所有路径都读取不到则重定向到最后的参数uri上.因此最后的uri参数必须存在而且是可以重定向的.
            #try_files适用于server,location配置块
            try_files /test_try1 /test_try2 /test_try3 @fallback;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
