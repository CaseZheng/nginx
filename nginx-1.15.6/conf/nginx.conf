#块配置项由一个块配置项名和一对大括号组成 events http server location upstream等都是块配置项
#块配置项一定会用大括号把所属的一系列所属的配置项包含进来,表示大括号内的配置项同时生效
#块配置项可以嵌套,内层块直接继承外层块

#配置项单位 空间: K或者k千字节 M或m兆字节  时间:ms(毫秒),s(秒),m(分钟),h(小时),d(天),w(周),M(月),y(年)

#以守护进程方式运行Nginx  默认on
daemon on;

#以mater/worker(一个master进程管理多个worker进程)方式工作,如果关闭就不会fork出worker子进程,而是master进程自身来处理请求  默认on
master_process on;

#error日志设置 语法: error_log /path/file level;
#/path/file是一个具体文件, /path/file也可以设置为/dev/null,不再输出任何日志(关闭error日志的唯一手段)
#level是日志等级 debug info notice warn error crit alert emerg 从左到右等级依次增大 如果想把日志等级设置为debug,必须在configure时加入--with-debug配置项
error_log  /var/log/nginx/error.log error;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;


#限制coredump核心转储文件的大小,防止core文件过大占满了磁盘 语法: worker_rlimit_core size;
worker_rlimit_core 1024M;

#指定coredump文件生成目录,worker进程的工作目录,该配置的唯一用途是设置coredump文件防止的目录,协助定位问题,需要确保worke进程有权限向working_directory指定目录写入文件 语法: working_directory path;
working_directory /data/nginx;

#定义环境变量 语法: env VAR|VAR=VALUE; 该配置让用户直接操作操作系统上的环境变量
#嵌入其他配置文件 语法: inclue /path/file; 将其它配置文件嵌入到当前的nginx.conf文件中,参数可以是绝对路径也可以是相对路径(相对nginx配置目录)
#include nginx.d/http/server.casezheng.com.conf
#include nginx.d/*.conf

#pid文件路径 保存master进程ID的pid文件存储路径.默认和configure设置的--pid-path所指定位置相同,需要确认nginx有权在相应目录中建立pid文件
#pid        logs/nginx.pid;

#ningx worker进程运行的用户及用户组
user  nobody;

#设置一个nginx worker进程可以打开的最大文件描述符个数
worker_rlimit_nofile 65535;

#限制信号队列 设置每个用户发往nginx的信号队列的大小,当某个用户的信号队列满了,该用户发送的信号量将被丢弃
worker_rlimit_sigpending 100;

#nginx worker进程个数 在master/worker运行方式下,定义worker进程的个数
worker_processes  1;

#绑定nginx worker进程到指定的CPU内核 语法: worker_cpu_affinity cpumask [cpumask...]; 该配置仅针对Linux操作系统有效

#SSL硬件加速 如果服务器上有SSL硬件加速设备,可以进行配置加快SSL协议的处理速度.用户可以使用OpenSSL提供的命令来查看是否有SSL硬件加速设备: openssl engine -t
ssl_engine device;

#nginx worker进程的优先级设置, 优先级有静态优先级和进程执行情况共同决定.这里设置的是静态优先级. 语法: worker_priority nice;   nice -20 ~ +19, -20最高优先级 +19最低优先级 希望nginx占用更多系统资源可以将其设置小点,但不建议比内核进程的nice(-5)小.
#worker_priority 0;


events {
    #对指定的客户端输出debug级别的日志 语法: debug_connection [IP|CIDR];  该配置属于事件类配置,必须放在events配置块中才有效,值可以是IP地址或CIDR地址 可以用于高并发请求下定位问题
    debug_connection 127.0.0.1;
    debug_connection 127.0.0.0/24;
    
    #accept锁 accept_mutext是Nginx的负载均衡锁,让多个worker进程轮流的,序列化地与新的客户端建立TCP连接,当一个worker进程建立的连接达到worker_connections配置的最大连接数的7/8时,大大减少该worker进程试图建立新TCP连接的机会,以此实现所有worker进程上处理的客户端请求数尽量接近. accept锁默认打开,关闭后建立TCP连接的耗时会更短,但worker进程间的负载会不均衡,因此不建议关闭它
    accept_mutext on;

    #使用accept锁后真正建立连接的延迟时间 语法: accept_mutext_delay Nms;    在使用accept锁后,同一时间只有一个worker进程可以获取到accept锁,accept锁不是阻塞锁,如果获取不到会立即返回.如果有一个worker进程试图获取accept锁而没有获取到,至少要等accept_mutex_delay定义的时间间隔后才能再次试图获取锁.

    #批量建立新连接 当事件模型通知有新连接时,尽可能对本次调度中客户端发起的所有TCP请求都建立连接. 语法: multi_accept [on|off];
    multi_accept off;

    #选择事件模型 语法: use [kququ | rtsig | epoll | /dev/poll | select | poll | eventport]; nginx默认会选择最合适的事件模型
    use epoll;

    #每个worker可以处理的最大连接数
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #server块 虚拟主机定义
    server {
        #监听端口 默认监听80端口 listen决定nginx服务如何监听端口.在listen后面可以只加IP地址,端口或主机名
        #listen 127.0.0.1:8080;
        #listen 127.0.0.1;  #不写端口时,默认监听80端口
        #listen *:80;
        #listen localhost:80;
        #listen后面也可以加其他参数
        #1. default/default_server: 将这个server块作为整个Web服务的默认server块.未设置则将nginx解析配置时找到的第一个server块作为默认块,当一个请求无法匹配配置文件中所有主机域名时,选择默认的虚拟主机.
        #2. backlog=num: 表示TCP中backlog队列的大小,默认为-1,表示不予设置.在TCP三次握手的工程中,进程还没有开始处理监听句柄,这时backlog队列会放置这些新连接.如果backlog队列已满,新的客户端试图建立新连接将会失败.
        #3. rcvbuf=size: 设置监听句柄的SO_RCVBUF参数 
        #4. sndbuf=size: 设置监听句柄的SO_SNDBUF参数
        #5. accept_filter: 设置accept过滤器,只对FreeBSD操作系统有效
        #6. deferred: 设置该参数,若用户发起建立连接请求,并且完成TCP的三次握手,内核也不会调度worker进程来处理这个连接,当用户真的发送请求数据时,内核才会调度worker进程处理这个连接,这个参数适合大并发的情况下,减轻worker进程的负担
        #7. bind: 绑定当前端口/地址对, 只有同时对一个端口监听多个地址才会生效
        #8. ssl: 在当前监听的端口上建立的连接必须基于SSL协议
        listen       80 default_server;

        #主机名称 server_name可以跟多个主机名称
        #server_name  localhost test.casezheng.date;
        #server_name  localhost 127.0.0.1;
        #当nginx处理一个HTTP请求时,nginx取出header头中的host,与每个server中的server_name匹配.匹配规则如下:
        #1. 完全匹配server_name
        #2. 通配符在前面的server_name
        #3. 通配符在后面的server_name
        #4. 正则表达式才匹配的server_name
        #5. 前面都未匹配到,找listen配置项后加了default或default_server的server块
        #6. 前面都未匹配到,找匹配listen端口的第一个server块
        #server_name后面跟空字符串表示匹配没有host这个HTTP头部的请求
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html;
            index  index.html index.htm;
        }

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}

        # deny access to .htaccess files, if Apache's document root
        # concurs with nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
    }


    # another virtual host using mix of IP-, name-, and port-based configuration
    #
    #server {
    #    listen       8000;
    #    listen       somename:8080;
    #    server_name  somename  alias  another.alias;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}


    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}

}
